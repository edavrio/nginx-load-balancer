Commands to achieve HTTPS using docker_c-nginx-load-balancer_1. We use
transparencycamp.eu as example domain. Certbot is already installed via
docker-compose and available in the `docker_c-certbot_1` container.


### Setup Let's Encrypt cron
Let's Encrypt certificates are valid for 90 days. Add a cronjob to
automatically check twice a day (on 11:27 and 23:27) if the certificates need
to be renewed and renews them if needed. To do that, add
the following line to `crontab` (using `sudo crontab -e`):
27 11,23 * * * sudo docker exec docker_c-certbot_1 certbot renew


### Setup TransIP API if it is not done yet (needed for DNS
### method)
Either copy `transip-rsa.key` and `transip.ini` from another server
(e.g., Oxygen) to the `docker` directory, or if there is no existing API
key, create a new one on the TransIP website copy it here in a file
called `docker/transip.key` and run:
   $ cd docker
   $ openssl rsa -in transip.key -out transip-rsa.key
   $ chmod 660 transip-rsa.key
   $ rm transip.key
   $ echo 'certbot_dns_transip:dns_transip_username = openstate' > transip.ini
   $ echo 'certbot_dns_transip:dns_transip_key_file = transip-rsa.key' >> transip.ini

Whitelist the IPv4 and IPv6 addresses of this server in the API configuration
settings on transip.nl


### Retrieve a certificate
First make sure the A and AAAA DNS records of the domain list the IP address
of this server.

(This step is only necessary if you retrieve the certificate using the
HTTP method. Normally we use the DNS method.)
Temporarily add the domain to
docker/nginx/conf.d/default.conf to retrieve the certificate using HTTP by
adding the following block:
server {
    listen 80;
    server_name
        transparencycamp.eu
        www.transparencycamp.eu:

    location ^~ /.well-known/acme-challenge/ {
        root /usr/share/nginx/html/;
    }
}
Reload Nginx:
   $ cd docker
   $ ./reload.sh

Now you can retrieve your certificate using either the DNS method (preferred,
as this allows you to get a wildcard certificate) or the HTTP method:
   $ sudo docker exec docker_c-certbot_1 certbot certonly --agree-tos -m developers@openstate.eu -d transparencycamp.eu -d *.transparencycamp.eu -a certbot-dns-transip:dns-transip --certbot-dns-transip:dns-transip-credentials transip.ini --certbot-dns-transip:dns-transip-propagation-seconds 240

   # HTTP method
   $ sudo docker exec docker_c-certbot_1 certbot certonly -m developers@openstate.eu --webroot --webroot-path /home/projects/html -d transparencycamp.eu -d www.transparencycamp.eu

This gives the following output:
IMPORTANT NOTES:
 - Congratulations! Your certificate and chain have been saved at:
   /etc/letsencrypt/live/transparencycamp.eu/fullchain.pem
   Your key file has been saved at:
   /etc/letsencrypt/live/transparencycamp.eu/privkey.pem
   Your cert will expire on 2019-05-15. To obtain a new or tweaked
   version of this certificate in the future, simply run certbot
   again. To non-interactively renew *all* of your certificates, run
   "certbot renew"


(This step is only necessary if you retrieve the certificate using the
HTTP method. Normally we use the DNS method.)
You can now remove the temporary changes you made to
docker/nginx/conf.d/default.conf. We will add the final default.conf
configurations below.


### Install the certificate
If this is the first certificate on the server you can now uncomment the top
server block in docker/nginx/conf.d/default.conf to enable a default response
for HTTPS requests.

Edit docker/nginx/conf.d/default.conf
NOTE: When editing default.conf using vim, make sure to add the following line
to your ~/.vimrc file otherwise the container will not receive any changes you
made to it! https://forums.docker.com/t/modify-a-file-which-mount-as-a-data-volume-but-it-didnt-change-in-container/2813/11:
set backupcopy=yes

Add the following section (make sure the proxy_pass and ssl paths are
correct! change '*' with 'www' if you don't use a wildcard certificate):
server {
    listen 443 ssl http2;
    server_name
        transparencycamp.eu
        *.transparencycamp.eu;
    ssl_certificate /etc/letsencrypt/live/transparencycamp.eu/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/transparencycamp.eu/privkey.pem;

    location / {
        proxy_pass http://docker_c-nginx_1;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # This block is only necessary if you retrieve the certificate using
    # the HTTP method. Normally we use the DNS method.
    location ^~ /.well-known/acme-challenge/ {
        root /usr/share/nginx/html/;
    }
}

Note: add new SSL domains to the ssl-test monitor which runs a daily check on
the domain using the SSL Labs SSL Server Test to see if something had changed
(e.g., problems with the certificate or vulnarability to a new hack resulting
in a lower grade). The file to add it to:
Oxygen:/home/projects/ssl-test/check-ssl.py

(optional but recommended) if you do not want the website to be reachable by
both HTTP and HTTPS, but only via HTTPS:
- Remove the domain from the HTTP section
- Add the following block to force redirect from HTTP to HTTPS (change
  '*' with 'www' if you don't use a wildcard certificate):
server {
    listen 80;
    server_name
        transparencycamp.eu
        *.transparencycamp.eu;

    return 301 https://$host$request_uri;
}
- Add this line which enables HSTS, to the SSL server section (e.g., add it
below the `ssl_certificate_key` line):
add_header Strict-Transport-Security max-age=31536000;

Reload nginx:
   $ cd docker
   $ ./reload.sh


### Migrate a certificate from one machine to another
When moving a website it is best to migrate the certificate instead of creating
a new one. The latter option is a bad idea because you first need to change the
DNS to point to the new machine in order to retrieve a new certificate, which
will result in failed HTTPS requests to the website because you don't have a
certificate yet (especially when using HSTS). So here is the way to migrate
a certificate:
   # On the old machine
   $ sudo cp -r --preserve=links /etc/letsencrypt ~
   $ sudo chown -R <your_user_name>:<your_user_name> ~/letsencrypt
   # Log out of the old machine and log into the new machine
   $ rsync -av <IP_OF_OLD_MACHINE>:letsencrypt ~
   $ sudo -i
   $ cp -r /home/<your_user_name>/letsencrypt/archive/<domain> /etc/letsencrypt/archive
   $ cp -r /home/<your_user_name>/letsencrypt/live/<domain> /etc/letsencrypt/live
   $ cp /home/<your_user_name>/letsencrypt/renewal/<domain>.conf /etc/letsencrypt/renewal
   # Make sure the settings in /etc/letsencrypt/renewal/<domain>.conf are correct.
   # Check the .conf files of other certificates if the format has changed.
   # Exit sudo and check if it works
   $ sudo certbot renew --dry-run
   # Remove `~/letsencrypt` on the old and new machine
   # Now follow the other steps above in the 'Install the certificate' section


### Remove domain from certificate
If a certificate contains multiple subdomains you sometimes want to remove one
of those subdomains. Simply first delete the certificate and then regenerate
the certificate without the subdomain, e.g.:
   # Note: you can retrieve the cert-name using `sudo certbot certificates` and check the value for 'Certificate Name'
   $ sudo certbot delete --cert-name transparencycamp.eu
   # Then use the 'sudo certbot certonly' as shown before in this document without the subdomain you want to remove
